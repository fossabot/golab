// Copyright Â© 2017 Michael Lihs
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package cmd

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"

	"github.com/hashicorp/go-cleanhttp"
	"github.com/hashicorp/go-rootcerts"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/xanzy/go-gitlab"
)

var cfgFile, caFile, caPath string

var gitlabClient *gitlab.Client

var RootCmd = &cobra.Command{
	Use:               "golab",
	Short:             "Gitlab CLI written in Go",
	Long:              `This application provides a Command Line Interface for Gitlab.`,
	DisableAutoGenTag: true, // disables footer in markdown files generated by cobra.gendoc
}

func Execute() {
	initRootCommand()
	if err := RootCmd.Execute(); err != nil {
		os.Exit(-1)
	}
}

func OutputJson(object interface{}) error {
	result, err := json.MarshalIndent(object, "", "  ")
	if err != nil {
		return err
	}
	fmt.Println(string(result))
	return nil
}

func initRootCommand() {
	RootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "(optional) golab config file (default is ./.golab.yml and $HOME/.golab.yml)")
	RootCmd.PersistentFlags().StringVar(&caFile, "ca-file", "", "(optional) provides a .pem file to be used in certificates pool for SSL connection")
	RootCmd.PersistentFlags().StringVar(&caPath, "ca-path", "", "(optional) provides a directory with .pem certificates to be used for SSL connection")

	// TODO this is an ugly hack to prevent re-initialization when mocked in testing
	if gitlabClient == nil {
		cobra.OnInitialize(initConfig)
		cobra.OnInitialize(initGitlabClient)
	}
}

func initConfig() {
	if cfgFile != "" { // enable ability to specify config file via flag
		viper.SetConfigFile(cfgFile)
	}

	if config, err := RootCmd.PersistentFlags().GetString("config"); err == nil && config != "" {
		viper.SetConfigFile(config)
	} else {
		viper.SetConfigName(".golab") // name of config file (without extension)
		viper.AddConfigPath(".")      // adding current directory as first search path
		viper.AddConfigPath("$HOME")  // adding home directory as second search path
	}
	viper.AutomaticEnv() // read in environment variables that match

	if err := viper.ReadInConfig(); err != nil {
		fmt.Println(err)
	}
}

func initGitlabClient() {
	baseUrl, err := url.Parse(viper.GetString("url"))
	if err != nil {
		fmt.Printf("Could not parse given URL '%s': %s", baseUrl, err)
	}

	httpClient, err := initHttpClient()
	if err != nil {
		panic("Error in initializing http client " + err.Error())
	}

	gitlabClient = gitlab.NewClient(httpClient, viper.GetString("token"))
	gitlabClient.SetBaseURL(baseUrl.String() + "/api/v4")
}

func initHttpClient() (*http.Client, error) {
	// see https://github.com/hashicorp/go-rootcerts
	tlsConfig := &tls.Config{}
	err := rootcerts.ConfigureTLS(tlsConfig, &rootcerts.Config{
		//CAFile: os.Getenv("GOLAB_CAFILE"),
		//CAPath: os.Getenv("GOLAB_CAPATH"),
		CAFile: caFile,
		CAPath: caPath,
	})
	if err != nil {
		return nil, err
	}
	c := cleanhttp.DefaultClient()
	t := cleanhttp.DefaultTransport()

	// use this line for debugging certificates
	//fmt.Println(tlsConfig.RootCAs)

	t.TLSClientConfig = tlsConfig
	c.Transport = t
	return c, nil

	// TODO this is an ugly hack to prevent SSL verification... see https://github.com/andygrunwald/go-jira/issues/52
	//tr := &http.Transport{
	//	TLSClientConfig: &tls.Config{InsecureSkipVerify : true},
	//}
	//return &http.Client{Transport: tr}, nil
}

func isoTime2String(time *gitlab.ISOTime) (string, error) {
	bytes, err := time.MarshalJSON()
	return string(bytes), err
}
